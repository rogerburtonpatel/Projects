
/**********************************************************
* Project 2: SixDegrees
* Comp 15
* README
* Roger A. Burtonpatel 
* 4/21/2021
*
*********************************************************/

Compile/run:
     - Compile using
            make SixDegress
     - run executable with
            ./SixDegrees dataFile [commandsFile] [outputFile]

     - run unit testing using 
             unit_test
     - run my testing script using 
             ./SixDegrees_tests.sh


Program Purpose:

This project handles a graph of artists and 
collaborations. Allows for user traversal through a graph to 
see artist collaborations and links between artists using breadth-first
or depth-first search, as well as an exclusive search. 


Acknowledgements: 
- I used stack overflow to look up several questions I had on 
- filereads, as well as CPlusPlusReference. 
- I used CPlusPlusReference for a reference on simple lambdas. 
- I used my hw2 implementation for formatting and some reference code
- Rhys helped me on testing and with some general knowledge 
- Kiran gave a hand on where to put file I/O 
- Elliot- conceptual conversation about file reads 
- Stephen- explained getline intuitively

Files: 

NOTE: output files are not provided. 

main.cpp:
     Handles simple driver commands like ensuring correct number of 
     arguments and running the simulation. 

SixDegrees.cpp:
     Implementation of SixDegrees class.  Main functionality of running the 
     Metro Simulation. Traverses the graph in a variety of ways
     and deals with output formatting. 

SixDegrees.h:
        Interface of SixDegrees class.

CollabGraph.cpp: 
        Implementation of CollabGraph class.  Main functionality of 
        putting Artists into the graph and and creating edges between them. 
        Contains numerous functions used in SixDegrees traversal algorithms. 

CollabGraph.h: 
        Interface of CollabGraph class. 
        
CollabGraph_tests.cpp: 
        Testing file for CollabGraph.cpp. Tests functions of 
        CollabGraph.cpp using unit_test. 

ABCD.txt:
        An example file containing a small sample list of artists and songs.
        Used to test file reads for files other than artists.txt. 

bfs_tests.txt
        Command file containing a number of of commands to test breadth-
        first search. See SixDegrees_tests.sh for more details. 

dfs_tests.txt
        Command file containing a number of of commands to test depth-
        first search. See SixDegrees_tests.sh for more details. 

not_tests.txt
        Command file containing a number of of commands to test exclusive
        search. See SixDegrees_tests.sh for more details. 

exit_not_test.txt
        Command file which tests inputting not, followed by an artist name, 
        followed by the end of the file. 

printquit.txt:
        Sample list of 2 commands to test command file reading. Ensures 
        quitting within a file works as intended. 

printprint.txt:
        Sample list of 2 commands to test command file reading. Ensures 
        reaching the end of a file without the "quit" command exists the 
        program. 

SixDegrees_tests.sh-
        A bash script I wrote to diff against the reference 
        implementation. Diffs outputs of all commands files using 
        my program and the reference implementation. 

Makefile: 
        File used for assembly of SixDegrees program. Allows use of 
        make SixDegrees command, make clean command, and unit_test
        command. Contains various build rules. 

README: 
        This file. 


Note:  the program handles all cases and contains no known bugs. 

Data Structures:

Artist- a simple struct. 
The struct, with member variables public by default, was used behind layers 
of abstraction. Having the data members as public instead of private within a
class mandated this, however; it rendered much of the other classes' function-
writing much easier, since accessing the members was trivial and required no 
getter or setter functions. 

CollabGraph- an unweighted graph of Artists. 
Using a graph for the first time was very interesting. With so many data 
structures that benefit from their unique shapes, I had though that 
graphs, of all structures, would do so, but the simple conjuction of two 
vectors is enough to get the job done. Though initially difficult to 
conceptualize, graphs ended up being fascinating. As a data structure, 
graphs are a collection of vertices connected by edges, both represented 
in individual storage units. Unweighted graphs have no unique costs associated 
with their edges. Graphs have the benefit of representing complicated 
relationships between many pieces of data, but are not very effective 
when the data are sparsely or not at all connected. More information can be
found in the file header of CollabGraph.cpp. 

Traversal efficiency of a graph can vary, going from O(V) to O(V + E) time
with some logarithmic ability in between, depending on the traversal chosen. 
More connections in a graph can mean longer or shorter traversal times 
depending on the method (longer for Breadth-first, often shorter for 
Depth-first.)

The graph itself- a hash table (unordered map)
The graph being an unordered map meant access to artists was extremely quick.
By using a key-value-pair system, verification of artists' presence within 
the graph could be done at what often ammounted to constant time, or O(1). 
If any collisions occurred, access would have been more within the range of 
linear time, or O(N). However, since we used the C++ STL unordered map, 
collisions are likely rare (since this hash table is fairly optimized). 
Still, collisions will always occur when hashing is involved.
The hash table was very useful for instant access of the artists when it 
came to checking if they were in the graph using enforce_valid_vertex().
Referencing the artists themselves was less easy without helper functions, 
which is a downside of unordered maps: they do not maintain an apparent 
order with which we can access any given element, like we can with an 
array list or linked list. 

Testing:

Starting note: I documented all of my testing, bugs, and breakthroughs in a 
seperate document called THOUGHT_PROCESS. While it is not included in this 
submission, I am happy to provide it upon request. The contents of 
THOUGHT_PROCESS are detailed formally here. 


Note on testing: I wrote tests as I went. After writing each function, I wrote
a test in CollabGraph_tests.cpp for the function. I tested 
CollabGraph.cpp using unit_test, and tested SixDegrees.cpp and main.cpp 
manually. In SixDegrees.cpp, I wrote functions and tested them one by one in 
main.cpp. For Phase 1, all of the file-reading functions and run loop are 
implemented (I used these for testing). For Phase 2, I tested all of the 
commands in SixDegrees using a testing paradigm I wrote that uses diff 
to test my output against that of the reference implementation. To run this 
test, execute ./SixDegrees_tests.sh. 


For each function I describe below, if it is not mentioned that I wrote a 
test for it explicitly, I did while writing the code to make sure it worked.
This seemed like a much more practical way of completing the program than 
doing all at once and getting overflowing errors. 

Second note on testing: When discussing the edge cases I used below, these 
involved attempting actions of attempting to report nonexistant paths, 
attempting to find paths between and neighbors of artists not in the graph,
and quitting from a commands file or by reaching the end of a file that 
did not contain the "quit" command. They also included numerous edge cases 
within the search commands (bfs, dfs, and not), such as exiting bfs, dfs, 
and not mid-command by reaching the end of the file, excluding artists 
not part of a path, excluding the source or dest artist, and many others. 
Please see SixDegrees_tests.sh for details. 


Final note on testing: I ran valgrind on every command I used in my final 
tests of SixDegrees. Every valgrind test returned zero memory errors or leaks. 
As of 5/2/2021, this program has no known bugs or glitches. 

TESTING PROCESS: 

4/17/2021 
This was my plan: 
0. Look over assignment again 
1. Make full implementation plan 
2. Go to office hours and ask if plan is reasonable 

Here is the plan: 

First think about how to conceptualize BFS and DFS. This will help me 
with report_path and get_vertex_neighbors. 

Implementing BFS: 
0. BFS: 
- Clear metadata
- Check if artists are in graph 
- make an int distance to be incremented 
a. Take the vertex start in the graph and mark 'visited' as false for all. 
Mark 'visited' as true for starting point 
Using get_vertex_neighbors: 
b. Make a queue for the neighbor vertices. Enqueue the starting vertex. 
Set predecessor to none. 
c. While queue is not empty 
- Dequeue vertex + Enqueue neighbors. 
 - Set their predecessors. 
 If == dest; return it and stop. 

Implementing DFS: 

1. DFS: 
- Clear metadata 
- Check if artists are in graph 
a. Take the vertex graph and mark 'visited' as false for all. Mark 'visited' as
true for starting point 
Set predecessor to none for start, otherwise to 'previous' input   
if vertex == dest; 
return vertex; 
else 
Using get_vertex_neighbors: 
b. for (vertex.neighbors)
- if not visited; 
- run DFS(neighbor, previous)


2. NOT: 
- Clear metadata 
- Check if artists are in graph 
a. Use DFS, except add condition 
-if not visited && not == [artist to exclude]
- run DFS(neighbor, previous)

HOW THE GRAPH IS REPRESENTED: 
The graph is represented as a vector of struct vertices with a corresponding 
vector of struct edges. Each vertex has a list of neighbors.

I drew some edge cases: 1 neighbor, no neighbors, artist not in graph

I then thought about my functions: 

FUNCTIONS: 
SixDegrees(artist_list_ifstream, output_list_ostream, command_list_ifstream);
Constructs SixDegrees simulation w various parameters provided in main 
BFS(Artist source, Artist dest));
Does the breadth-first search and sets predecessors 
DFS(Artist source, Artist dest);
Does the depth-first search and sets predecessors 
not(Artist source, Artist dest);
Does the exclusive depth-first search and sets predecessors 
print_entire_graph()
prints the whole graph


run(several args)- runs the loop 


TIMELINE: 
Do report_path(); get_vertex_neighbors() today; test and write main(). Submit. 
Friday: SixDegrees BFS and DFS 
Sunday-Monday: SixDegrees PopulateGraph, print. Also start modularizing for 
commands and output. 
Tues-Weds: final tests and submit Weds at noon (6 hr before deadline for 
breathing room).

I worked a bit on Makefile while waiting for office hours check-in. 

4/20/2021 
I implemented report_path and get_vertex_neighbors(). 
As I wrote each function, I wrote a test for each.
I also wrote some "test tests" to see how the Artist and CollabGraph
classes worked in practice. These were immensely helpful.

I tested many cases: with varying numbers of artists, existent and non-
connections, and with a predecessor loop, no songs for an artist, etc.
I tested with my own data and created numerous edge cases. 

I finished the functions and testing and began to work on file reads. 

4/21/2021
I wrote and implemented SixDegrees.h and .cpp. I tested the graph 
population and construction, which I did within the SixDegrees class, 
in main.cpp. I used valgrind and diff'ed against the reference implmentation. 

I tested using custom command files and custom artist files, as well as 
artists.txt. I used a script - diff.sh- which I wrote to speed up the process. 

I continued testing, finding some bugs involving getline and eof, which I wrote 
a line to check for. I carefully looked over my functions and testing program, 
then wrote the README and submitted Phase 1 using make provide. 

4/22/2021 
I started on completing the SixDegrees class within the .cpp and .h files. 
I did lots of cleaning and documentation, then started writing and testing my 
functions 

4/25/2021 
I wrote bfs, dfs, and not. Here are some details from writing and testing:
- I tested as I wrote, making sure to run the program every time I added new 
code. I used manual commands. 
- I found bfs tricky at first- I did a lot of testing and was having trouble 
with correctly formatting the path. I even got a segmentation fault once! 
I realized it had to do with not correctlyl entering a while loop, and 
fixed the issue. As the later part of my testing process, I diff'd 
output files with the reference implementation.

- To do DFS, I realized that replacing the bfs queue with a stack would 
serve my purpose, since it would test a path fully before trying the next
one. No issues here, though I did test many times (not using diff since 
it would not necessarily match with the reference).

- I got through some of not and then had some troubles. I was having 
a hard time finding a way to exclude a vector of artists, as well as 
correctly reading and processing an empty exclusion list or one that 
didn't end in * (rather ended in eof.) I had a lot of 
other work, so I decided to finish it later. 

5/2/2021
I realized I had used none of my late tokens, so I decided to cash them 
all in. I finished not by using a simple lambda, which seemed the best 
and most visually-friendly solution in conjunction with the rest of my 
code. I made sure to have a case where if I excluded the source or dest 
artists, no path would be found. I tested a TON with many edge cases, 
using my testing paradigm. Eventually, I finished. 

5/4/2021
I continued testing, finding a bug regarding order of 
conditions in a while statement, which I then fixed.
I carefully looked over my functions and testing program, 
then wrote the rest of the README and submitted Phase 2 using make provide. 

Phase 1 took me about 7 hours of good, solid coding and testing. The code 
itself was brief; testing and debugging took most of the time. Having 
MetroSim as a reference saved a TON of time and felt very rewarding to use 
as a base. 

Phase 2 took me around 10 hours, with most of my time spent figuring out how
to implement the commands and not too much time spent writing pages of code. 
I liked the conceptual aspect of the project, and I feel a stronger programmer 
because of it. 

Thanks for a great project and a great course! 
