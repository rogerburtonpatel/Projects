3/5/2021 
Looked at spec and made files. Started thinking about implementation. 

3/7/2021 
Made implementation plan. Declared functions in DatumStack.h and 
RPNCalc.h files and thought about how to write them. 

3/9/2021 
Went to OH for check-off and wrote functions for DatumStack.cpp, testing as
I went using DatumStack_tests.cpp. Also wrote parseRString.cpp. 

Akash- using DatumStack in RPNCalc. 

Sam R- parseRString
1. Use recursion- I did!  
2. Use bracket iterator 


3/9/2021 
DatumStack implementation. Plan: 
1. Write out all functions within DatumStack.cpp. They are already declared in 
DatumStack.h. 
2. Fill in each function one at a time. Write a test for each as I go in 
DatumStack_tests.cpp and test using unit_test 
3. Complete. 


For parseRString, I implemented a recursive definition and an 
iterative definition. I would like to be graded on the iterative 
definition since I know it works in all cases. HOWEVER: The recursive
works for cin but not for a file read IF reading a direct file stream 
of a file containing a normally formatted rstring (such as 
 { 1 { 4 2 / } / }  )

it DOES work if the file contains an rstring with the first open bracket 
missing, such as 
1 { 4 2 / } / } 

which is to be assumed since the function will only be called in a
file read (as in cin) after the first open bracket. Thus the recursive method 
works, albeit not with a direct read. Therefore, I included two testing files: 
rStringTestIterative.cyl and rStringTestRecursive.cyl. These each work for 
their respective institution of the function. Please feel free to comment out
or in either half to examine its functionality. (Note that the iterative 
version works for either file.)

I know this because I tested using main.cpp. This is also included in the 
submission. 


3/12/21 

Started implementing RPNCalc.cpp. 

I think I'll write run() first. run() will take in an input stream as a 
parameter. 

run() will use switch statements for each of its functions. 

ALTERNATIVE: run() will call a private function that takes a stream 
as its input 

For ints, it will use got_int(). 

string input; 
int value; 
if (got_int(input, &value)) {
    Datum d(value); 
    newDatumStack.push(d);
}


For math, pop the top two, use isInt() Datum helper function on them, and 
then do some math. 


Etc. 
For file, open a filestream and execute run() private on the file stream.
Will work? 
Who knows, but recursion is dope! 

Alternatively, just open the filestream and redirect it to cin. 

Check up on @655


I wrote functions and tested them with print statements. For example, 
when taking in a value, I would print the value to cout. 

3/13/2021 
Implemented all simple commands. Started on complex commands. Used 
print() for debugging. Tested vs reference implementation. 
Also tested many commands on the same line. These included: 
5 print drop print 
Which yielded: 
5
Error: empty_stack

NOTE: for ==, I tested 1 vs #t and - vs #f. 
Credit: Coby Formaggio! This comparison worked as expected, 
but seemed an important edge case to check. 

3/14/2021 Happy pi day! 

Put parseRString into RPNCalc.cpp and implemented a way to 
read rstrings. My plan was: 
1. if (input == "{") 
    make a new datum rstring using parseRString; 
    newDatumStack.push(new datum); 
2. for exec: 
(error condition)
    istringstream rstringstream(newDatumStack.top().getRString());
    run_stream(rstringstream);



as expected. 


use } bracket to close while loop with boolean 
quit uses EXIT_SUCCESS? or boolean! 

grace in readme 


QUESTIONS: 
1. parseRString() and gotint() copied into RPNCalc.cpp or #included as .h 
files? 
2. Need to unit_test for RPNCalc.cpp or manual testing is fine? 
Did detailed testing for MetroSim. 
3. length() -5 vs 4? Why? A: All set. B/c added extra space. 


Plan for if: 
check if top is rstring. if not, throw error. if so, store it in a 
variable. pop either way. 
do the same. 
if top is not boolean, throw error. otherwise, store in var. pop either way. 
Then read boolean var. If true, push first rstring and exec it. 
If false, push 2nd rstring and exec it. 

pass errors by reference 

3/15/2021 
Did if(). Errors with file reads due to rstring parsing. For some reason, 
reading rstrings from file twice, resulting in 
{
{ rstring }

instead of 
{ rstring }

Fixed error. Had to do with taking the input at the beginning of the while 
loop. When reaching the end of the file, it executed the while loop one more
time before "realizing" it was at eof() (or fail() in this case) and would 
read the last input again- in this case, an open brace. This resulted in 
an rstring in a file leaving an extraneous "{" at the top of the stack. 

3/16/2021 
Fully completed RPNCalc.cpp. I had been using testing files as I went, and 
began to comment on them using % and compiling them using ./cylc. I ended with
five testing files: 
0. rstring.cyl 
1. test.cyl 
2. quit.cyl
3. quit2.cyl 
4. errors.cyl 

3/17/2021

I finished my README and submitted using provide. 
